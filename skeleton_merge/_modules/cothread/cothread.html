
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cothread.cothread &#8212; cothread 3.dev25+gc491610 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script src="../../_static/documentation_options.js?v=76bddaed"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=30646c52"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/cothread/cothread';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.14.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://DiamondLightSource.github.io/cothread/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'skeleton_merge';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = false;
        </script>
    <link rel="icon" href="../../_static/dls-favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/dls-logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/dls-logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
    <p class="title logo__title">cothread</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../user/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../developer/index.html">
                        Developer Guide
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/DiamondLightSource/cothread/releases">
                    Release Notes
                  </a>
                </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/DiamondLightSource/cothread" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/cothread" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fas fa-cube fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="versionswitcherbutton" type="button" role="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="listbox" aria-controls="versionswitcherlist" aria-label="Version switcher list">
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="versionswitcherlist" class="version-switcher__menu dropdown-menu list-group-flush py-0" role="listbox" aria-labelledby="versionswitcherbutton">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../user/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../developer/index.html">
                        Developer Guide
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/DiamondLightSource/cothread/releases">
                    Release Notes
                  </a>
                </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/DiamondLightSource/cothread" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/cothread" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fas fa-cube fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="versionswitcherbutton" type="button" role="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="listbox" aria-controls="versionswitcherlist" aria-label="Version switcher list">
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="versionswitcherlist" class="version-switcher__menu dropdown-menu list-group-flush py-0" role="listbox" aria-labelledby="versionswitcherbutton">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">cothread.cothread</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for cothread.cothread</h1><div class="highlight"><pre>
<span></span><span class="c1"># This file is part of the Diamond cothread library.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2007 James Rowland, 2007-2012 Michael Abbott,</span>
<span class="c1"># Diamond Light Source Ltd.</span>
<span class="c1">#</span>
<span class="c1"># The Diamond cothread library is free software; you can redistribute it</span>
<span class="c1"># and/or modify it under the terms of the GNU General Public License as</span>
<span class="c1"># published by the Free Software Foundation; either version 2 of the License,</span>
<span class="c1"># or (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># The Diamond cothread library is distributed in the hope that it will be</span>
<span class="c1"># useful, but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c1"># Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="c1"># Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="c1">#</span>
<span class="c1"># Contact:</span>
<span class="c1">#      Dr. Michael Abbott,</span>
<span class="c1">#      Diamond Light Source Ltd,</span>
<span class="c1">#      Diamond House,</span>
<span class="c1">#      Chilton,</span>
<span class="c1">#      Didcot,</span>
<span class="c1">#      Oxfordshire,</span>
<span class="c1">#      OX11 0DE</span>
<span class="c1">#      michael.abbott@diamond.ac.uk</span>

<span class="sd">&#39;&#39;&#39;Simple cooperative threading using coroutines.  The following functions</span>
<span class="sd">define the interface provided by this module.</span>

<span class="sd">    Spawn(function, arguments...)</span>
<span class="sd">        A new cooperative thread, or &quot;task&quot;, is created as a call to</span>
<span class="sd">        function(arguments).  Control is not transferred to the task until</span>
<span class="sd">        control is yielded.</span>

<span class="sd">    Sleep(delay)</span>
<span class="sd">    SleepUntil(time)</span>
<span class="sd">        The calling task is suspended until the given time.  Sleep(delay)</span>
<span class="sd">        suspends the task for at least delay seconds, SleepUntil(time)</span>
<span class="sd">        suspends until the specified time has passed (time is defined as the</span>
<span class="sd">        value returned by time.time()).</span>
<span class="sd">            Control is not returned to the calling task until all other</span>
<span class="sd">        active tasks have been processed.</span>

<span class="sd">    Yield()</span>
<span class="sd">        Yield() suspends control so that all other potentially busy tasks can</span>
<span class="sd">        run.</span>

<span class="sd">Instances of the Event object can be used for communication between tasks.</span>
<span class="sd">The following Event object methods are relevant.</span>

<span class="sd">    Wait()</span>
<span class="sd">    Wait(timeout)</span>
<span class="sd">        Waits for the event object to be signalled or for the timeout to</span>
<span class="sd">        expire (if specified).  Returns True if a signal was received, False</span>
<span class="sd">        if a timeout ocurred.</span>

<span class="sd">    Signal()</span>
<span class="sd">        Signals the event object, releasing at least one waiting task.</span>

<span class="sd">Similarly the EventQueue can be used for communication.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># It might be worth taking a close look at:</span>
<span class="c1">#   http://wiki.secondlife.com/wiki/Eventlet</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_coroutine</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">py23</span>

<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;COTHREAD_CHECK_STACK&#39;</span><span class="p">):</span>
    <span class="n">_coroutine</span><span class="o">.</span><span class="n">enable_check_stack</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">coselect</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="kn">import</span> <span class="nn">_thread</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">thread</span> <span class="k">as</span> <span class="nn">_thread</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Spawn&#39;</span><span class="p">,</span>            <span class="c1"># Spawn new task</span>

    <span class="s1">&#39;Sleep&#39;</span><span class="p">,</span>            <span class="c1"># Suspend task for given delay</span>
    <span class="s1">&#39;SleepUntil&#39;</span><span class="p">,</span>       <span class="c1"># Suspend task until specified time</span>
    <span class="s1">&#39;Yield&#39;</span><span class="p">,</span>            <span class="c1"># Suspend task for immediate resumption</span>

    <span class="s1">&#39;Event&#39;</span><span class="p">,</span>            <span class="c1"># Event for waiting and signalling</span>
    <span class="s1">&#39;RLock&#39;</span><span class="p">,</span>            <span class="c1"># Recursive lock</span>
    <span class="s1">&#39;Pulse&#39;</span><span class="p">,</span>            <span class="c1"># Event for dynamic condition variables</span>
    <span class="s1">&#39;EventQueue&#39;</span><span class="p">,</span>       <span class="c1"># Queue of objects with event handling</span>
    <span class="s1">&#39;ThreadedEventQueue&#39;</span><span class="p">,</span>   <span class="c1"># Event queue designed to work with threads</span>
    <span class="s1">&#39;WaitForAll&#39;</span><span class="p">,</span>       <span class="c1"># Wait for all events to become ready</span>

    <span class="s1">&#39;AbsTimeout&#39;</span><span class="p">,</span>       <span class="c1"># Converts timeout into absolute deadline format</span>
    <span class="s1">&#39;GetDeadline&#39;</span><span class="p">,</span>      <span class="c1"># Returns deadline associated with timeout</span>
    <span class="s1">&#39;Deadline&#39;</span><span class="p">,</span>         <span class="c1"># Converts deadline into timeout format</span>

    <span class="s1">&#39;Timedout&#39;</span><span class="p">,</span>         <span class="c1"># Timeout exception raised by event waiting</span>

    <span class="s1">&#39;Quit&#39;</span><span class="p">,</span>             <span class="c1"># Immediate process quit</span>
    <span class="s1">&#39;WaitForQuit&#39;</span><span class="p">,</span>      <span class="c1"># Wait until Quit() is called</span>

    <span class="s1">&#39;Timer&#39;</span><span class="p">,</span>            <span class="c1"># One-shot cancellable timer</span>
    <span class="s1">&#39;Callback&#39;</span><span class="p">,</span>         <span class="c1"># Simple asynchronous synchronisation</span>
    <span class="s1">&#39;CallbackResult&#39;</span><span class="p">,</span>   <span class="c1"># Asynchronous synchronisation with result</span>
    <span class="s1">&#39;scheduler_thread_id&#39;</span><span class="p">,</span> <span class="c1"># For checking we&#39;re in cothread&#39;s thread</span>
<span class="p">]</span>




<span class="k">class</span> <span class="nc">_TimerQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A timer queue: objects are held on the queue in timeout sequence.&#39;&#39;&#39;</span>

    <span class="c1"># The queue is implemented using the bisect function to insert objects</span>
    <span class="c1"># into the queue without having to resort the list.  This is cheap and</span>
    <span class="c1"># cheerful to implement and runs fast enough.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We maintain the list of timeouts and the associated tasks separately</span>
        <span class="c1"># so that bisect searching can safely search the timeouts list without</span>
        <span class="c1"># trying to compare wakeups.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Adds value to the queue with the specified timeout.&#39;&#39;&#39;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the timeout of the queue.  Only valid if queue not empty.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">wake_expired</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="n">expired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">expired</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_TIMEOUT</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the number of entries on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This is called to cancel a timeout.  We add this to our garbage</span>
<span class="sd">        count, triggering a garbage collect if appropriate.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">timeouts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wakeups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">woken</span><span class="p">():</span>
                    <span class="n">timeouts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                    <span class="n">wakeups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__timeouts</span> <span class="o">=</span> <span class="n">timeouts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeups</span> <span class="o">=</span> <span class="n">wakeups</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_WakeupQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__waiters&#39;</span><span class="p">,</span>        <span class="c1"># List of wakeup objects pending wakeup</span>
        <span class="s1">&#39;__garbage&#39;</span><span class="p">,</span>        <span class="c1"># Count of expired wakeup objects</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Every time a timeout occurs a waiter is left behind on the timer</span>
        <span class="c1"># queue.  We keep count of these as &quot;garbage&quot;, and at the appropriate</span>
        <span class="c1"># time we can garbage collect the queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waiter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wake_all</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wake_all</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_NORMAL</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Wake the first task that actually wakes, mark the rest as</span>
                <span class="c1"># junk.</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">_WAKEUP_NORMAL</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">[:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># A cancelled wait becomes garbage on the waiting queue.  We keep</span>
        <span class="c1"># count of how much garbage there is -- once the queue has more</span>
        <span class="c1"># garbage than waiters it&#39;s probably time to rebuild the queue and</span>
        <span class="c1"># keep only those waiters which haven&#39;t been woken yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">woken</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__garbage</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_Wakeup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A _Wakeup object is used when a task is to be suspended on one or more</span>
<span class="sd">    queues.  On wakeup the original task is woken, but only once: this is</span>
<span class="sd">    used to ensure that entries on other queues are effectively cancelled.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__task&#39;</span><span class="p">,</span>           <span class="c1"># Coroutine associated with task to wake</span>
        <span class="s1">&#39;__wakeup_task&#39;</span><span class="p">,</span>    <span class="c1"># Action to take on wakeup</span>
        <span class="s1">&#39;__queue&#39;</span><span class="p">,</span>          <span class="c1"># Queue where this wakeup object resides</span>
        <span class="s1">&#39;__timers&#39;</span><span class="p">,</span>         <span class="c1"># Timeout queue for this wakeup</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">timers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span> <span class="o">=</span> <span class="n">wakeup_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="n">queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span> <span class="o">=</span> <span class="n">timers</span>

    <span class="k">def</span> <span class="nf">wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">:</span>
            <span class="c1"># Let the scheduler know that this task has been woken, and forget</span>
            <span class="c1"># about it, so we don&#39;t wake it again.</span>
            <span class="c1">#    Note that it&#39;s rather important to mark this wakeup as woken</span>
            <span class="c1"># *before* calling the queue cancel() functions, as otherwise</span>
            <span class="c1"># their garbage collection will be confused!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Each queue needs to be cancelled if it&#39;s not the wakeup reason.</span>
            <span class="c1"># This test also properly deals with interrupt wakeup, which</span>
            <span class="c1"># requires both queues to be cancelled.</span>
            <span class="k">if</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">_WAKEUP_NORMAL</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">reason</span> <span class="o">!=</span> <span class="n">_WAKEUP_TIMEOUT</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__timers</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

            <span class="c1"># Also drop our reference to the queue to avoid overextending</span>
            <span class="c1"># object lifetime.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">woken</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="ow">is</span> <span class="kc">None</span>


<span class="c1"># Task wakeup reasons</span>
<span class="n">_WAKEUP_NORMAL</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1"># Normal wakeup</span>
<span class="n">_WAKEUP_TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c1"># Wakeup on timeout</span>
<span class="c1"># A third reason, transfering exception to another cothread, is encoded as a</span>
<span class="c1"># tuple.</span>


<span class="c1"># Important system invariants:</span>
<span class="c1">#   - A running task is not on any waiting queue.</span>
<span class="c1">#       This is enforced by:</span>
<span class="c1">#       1) when a task it suspended it is recorded on waiting queues by using</span>
<span class="c1">#          a shared _Wakeup() object;</span>
<span class="c1">#       2) the .wakeup() method is always used before resuming the task.</span>

<span class="k">class</span> <span class="nc">_Scheduler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Coroutine activity scheduler.&#39;&#39;&#39;</span>

    <span class="c1"># The scheduler runs in a dedicated stack.  It doesn&#39;t need much stack.</span>
    <span class="n">SCHEDULER_STACK_SIZE</span> <span class="o">=</span> <span class="mi">65536</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Creates the scheduler in its own coroutine and starts it running.</span>
<span class="sd">        We switch to the scheduler long enough for it to complete</span>
<span class="sd">        initialisation.&#39;&#39;&#39;</span>
        <span class="c1"># We run the scheduler in its own coroutine to allow the main task to</span>
        <span class="c1"># participate in scheduling.  This produces its own complications but</span>
        <span class="c1"># makes for a more usable system.</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="n">scheduler_task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">current</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__scheduler</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">SCHEDULER_STACK_SIZE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">scheduler_task</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__scheduler</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">main_task</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The top level scheduler loop.  Starts by creating the scheduler,</span>
<span class="sd">        and then manages dispatching from the top level.&#39;&#39;&#39;</span>

        <span class="c1"># First create the scheduler and pass it back to our caller, who we</span>
        <span class="c1"># expect to be the main task.  The next time we get control it&#39;s time</span>
        <span class="c1"># to run the scheduling loop.</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">main_task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># If the schedule loop raises an exception then propagate the</span>
        <span class="c1"># exception up to the main thread before restarting the scheduler.</span>
        <span class="c1"># This has mostly the right effects: a standalone program will</span>
        <span class="c1"># terminate, and an interactive program will receive back control, and</span>
        <span class="c1"># the scheduler should carry on operating.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__schedule_loop</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># Switch to the main task asking it to re-raise the interrupt.</span>
                <span class="c1"># First we have to make sure it&#39;s not on the run queue.</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="n">main_task</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="k">break</span>
                <span class="c1"># All task wakeup entry points will interpret this as a request</span>
                <span class="c1"># to re-raise the exception.  Pass through the exception info.</span>
                <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">main_task</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># List of all tasks that are currently ready to be dispatched.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of tasks waiting for ready_queue to become empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span> <span class="o">=</span> <span class="n">_WakeupQueue</span><span class="p">()</span>
        <span class="c1"># List of tasks waiting for a timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span> <span class="o">=</span> <span class="n">_TimerQueue</span><span class="p">()</span>
        <span class="c1"># Scheduler coroutine: this will be switched to whenever any other</span>
        <span class="c1"># task decides to sleep.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="c1"># Initially the schedule loop will run freely with its own select.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Dictionary of waitable descriptors for which polling needs to be</span>
        <span class="c1"># done.  Each entry consists of an event mask together with a list of</span>
        <span class="c1"># interested tasks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># By default use blocking poll while waiting for the next event.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_poll_block</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_block</span>


    <span class="k">def</span> <span class="nf">__tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This must be called regularly to ensure that all waiting tasks are</span>
<span class="sd">        processed.  It processes all tasks that are ready to run and then runs</span>
<span class="sd">        all timers that have expired.&#39;&#39;&#39;</span>
        <span class="c1"># Wake up all the expired timers on entry.  These go to the end of</span>
        <span class="c1"># the ready queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">wake_expired</span><span class="p">()</span>
        <span class="c1"># If the ready queue is still empty, now&#39;s the time to run the yield</span>
        <span class="c1"># queue.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="o">.</span><span class="n">wake</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Pick up the ready queue and process every task in it.  When each</span>
        <span class="c1"># task is resumed it is passed a flag indicating whether it has been</span>
        <span class="c1"># resumed because of an expired timer, or for some other reason</span>
        <span class="c1"># (typically either a voluntary suspend, or a successful wait for an</span>
        <span class="c1"># event).</span>
        <span class="n">ready_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">reason</span> <span class="ow">in</span> <span class="n">ready_queue</span><span class="p">:</span>
            <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__schedule_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This runs a scheduler loop without returning.&#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Dispatch all waiting tasks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tick</span><span class="p">()</span>

            <span class="c1"># Now see how long we have to wait for the next tick</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="p">:</span>
                <span class="c1"># There are ready tasks: don&#39;t wait</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="p">:</span>
                <span class="c1"># There are timers waiting to fire: wait for the first one.  We</span>
                <span class="c1"># don&#39;t sleep for less than 1ms: there&#39;s not a lot of point in a</span>
                <span class="c1"># shorter timeout, and this works around some timer calculation</span>
                <span class="c1"># quirks.</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">timeout</span><span class="p">()</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="mf">0.001</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Nothing to do: block until something external happens.</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Finally suspend until something is ready.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_poll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__poll_suspend</span><span class="p">(</span><span class="n">delay</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__poll_suspend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Suspends the scheduler until the appropriate ready condition is</span>
<span class="sd">        reached.  Returns lists of ready file descriptors and events.&#39;&#39;&#39;</span>
        <span class="n">poll_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span> <span class="o">=</span> \
            <span class="n">coselect</span><span class="o">.</span><span class="n">_compute_poll_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If we&#39;re not being polled from outside, run our own poll.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll_block</span><span class="p">(</span><span class="n">poll_list</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the scheduler loop was invoked from outside then return</span>
            <span class="c1"># control back to the caller: it will provide the select</span>
            <span class="c1"># operation we need.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">poll_list</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">poll_scheduler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ready_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This is called when the scheduler needs to be controlled from</span>
<span class="sd">        outside.  It will perform a full round of scheduling before returing</span>
<span class="sd">        control to the caller.</span>
<span class="sd">            Two values are returned, a list of descriptors and events plus</span>
<span class="sd">        a timeout, being precisely the values required for a call to</span>
<span class="sd">        poll_block().  A sensible default outer scheduler loop would be</span>

<span class="sd">            ready_list = []</span>
<span class="sd">            while True:</span>
<span class="sd">                ready_list = poll_block(*poll_scheduler(ready_list))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Nested pollers will not work&#39;</span>

        <span class="c1"># Switching to the scheduler will return control to us when the next</span>
        <span class="c1"># round is complete.</span>
        <span class="c1">#    Note that the first time this is called we may get an incomplete</span>
        <span class="c1"># schedule, as we may be resuming inside the dispatch loop: in effect</span>
        <span class="c1"># the first call to this routine interrupts the original scheduler.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="n">ready_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__poll_callback</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># This case arises if we are main and the scheduler just died.</span>
            <span class="n">py23</span><span class="o">.</span><span class="n">raise_with_traceback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Spawns a new task: function is spawned as a new background task</span>
<span class="sd">        as a child of the scheduler task.&#39;&#39;&#39;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">_WAKEUP_NORMAL</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">do_yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Hands control to the next task with work to do, will return as</span>
<span class="sd">        soon as there is time.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__yield_queue</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wait_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until</span><span class="p">,</span> <span class="n">suspend_queue</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The calling task is suspended.  If a deadline is given then the</span>
<span class="sd">        task will definitely be woken up when the deadline is reached if not</span>
<span class="sd">        before.  If a suspend_queue is given then the task is added to it</span>
<span class="sd">        (and it is the caller&#39;s responsibility to ensure the task is woken</span>
<span class="sd">        up, with a call to wakeup()).</span>
<span class="sd">            Returns True iff the wakeup is from a timeout.&#39;&#39;&#39;</span>
        <span class="c1"># If no wakeup has been specified, create one.  This is a key</span>
        <span class="c1"># component for ensuring consistent behaviour of the system: the</span>
        <span class="c1"># wakeup object ensures each task is only woken up exactly once.</span>
        <span class="k">if</span> <span class="n">wakeup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wakeup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__Wakeup</span><span class="p">(</span><span class="n">suspend_queue</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>

        <span class="c1"># If a timeout or a suspension queue has been specified, add</span>
        <span class="c1"># ourselves as appropriate.  Failing either of these it&#39;s up to the</span>
        <span class="c1"># caller to arrange a wakeup.</span>
        <span class="k">if</span> <span class="n">suspend_queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">suspend_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wakeup</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">until</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">wakeup</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>

        <span class="c1"># Suspend until we&#39;re woken.</span>
        <span class="c1"># Normally this call will return control to __tick(), but there are</span>
        <span class="c1"># two other cases to consider.  On the very first suspend control is</span>
        <span class="c1"># returned to the top of __scheduler(), and more interestingly, on</span>
        <span class="c1"># suspending immediately after calling poll_scheduler() control is</span>
        <span class="c1"># returned to __select().  This last case expects a list of ready</span>
        <span class="c1"># descriptors to be returned, so we have to be compatible with this!</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coroutine</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># We get here if main is suspended and the scheduler decides</span>
            <span class="c1"># to die.  Make sure our wakeup is cancelled, and then</span>
            <span class="c1"># re-raise the offending exception.</span>
            <span class="n">wakeup</span><span class="o">.</span><span class="n">wakeup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">py23</span><span class="o">.</span><span class="n">raise_with_traceback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="n">_WAKEUP_TIMEOUT</span>

    <span class="k">def</span> <span class="nf">poll_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poller</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Cooperative poll: the calling task is suspended until one of</span>
<span class="sd">        the specified waitable objects becomes ready or the timeout expires.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Add our poller to the appropriate poll event queues so that we&#39;ll</span>
        <span class="c1"># get woken.  Note that we don&#39;t need to worry about coming off the</span>
        <span class="c1"># queue: this&#39;ll be managed in _compute_poll_list later on</span>
        <span class="n">poller</span><span class="o">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__Wakeup</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">poller</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poller</span><span class="p">)</span>
        <span class="c1"># It&#39;s vital to yield during this call, even if we have actually</span>
        <span class="c1"># timed out -- otherwise the wakeup we&#39;ve just added to the poll</span>
        <span class="c1"># queue will get processed when it&#39;s no longer valid (oops).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">poller</span><span class="o">.</span><span class="n">wakeup</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">until</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">until</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wakeup_task</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__timer_queue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__wakeup_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ready_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">reason</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__wakeup_poll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_result</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Called with the result of a system poll: a list of file descriptors</span>
<span class="sd">        and wakeup reasons.  Each waiting task is informed.&#39;&#39;&#39;</span>
        <span class="c1"># Work through all the notified files: with each file is a received</span>
        <span class="c1"># event mask which we&#39;ll pass through to the interested task.</span>
        <span class="c1">#</span>
        <span class="c1"># Some care is required here if we are to neither deliver spurious</span>
        <span class="c1"># wakeups nor lose wakeups.</span>
        <span class="c1">#     We make two assumption about our wakeup call, translating into</span>
        <span class="c1"># assumptions on either coselect.poll_block or poll_scheduler:</span>
        <span class="c1">#   1/ if an event is ready on a file we will eventually be notified;</span>
        <span class="c1">#   2/ if an event is not ready we will not be notified -- in other</span>
        <span class="c1">#      words, if a poll notify occurs we can safely access the file</span>
        <span class="c1">#      without risk of blocking.</span>
        <span class="c1">#</span>
        <span class="c1"># The goal of the loop below is to translate these assumptions into</span>
        <span class="c1"># corresponding properties on poll_until.  The problem arises when</span>
        <span class="c1"># there is more than one listener on an event, as the first listener</span>
        <span class="c1"># may consume the event before subsequent listeners receive it.</span>
        <span class="c1">#     The simplest solution is to be to communicate each event to just</span>
        <span class="c1"># one interested listener, but ensure that the event remains</span>
        <span class="c1"># monitored.</span>
        <span class="k">for</span> <span class="n">file</span><span class="p">,</span> <span class="n">events</span> <span class="ow">in</span> <span class="n">poll_result</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poller</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__poll_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="c1"># Consume any events taken by the woken process</span>
                <span class="n">events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">poller</span><span class="o">.</span><span class="n">notify_wakeup</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>


<div class="viewcode-block" id="Timedout">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Timedout">[docs]</a>
<span class="k">class</span> <span class="nc">Timedout</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Waiting for event timed out.&#39;&#39;&#39;</span></div>



<div class="viewcode-block" id="AbsTimeout">
<a class="viewcode-back" href="../../user/cothread.html#cothread.AbsTimeout">[docs]</a>
<span class="k">def</span> <span class="nf">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A timeout is represented in one of three forms:</span>

<span class="sd">    None            A timeout that never expires</span>
<span class="sd">    interval        A relative timeout interval</span>
<span class="sd">    (deadline,)     An absolute deadline</span>

<span class="sd">    This routine checks that the given input is in one of these three forms</span>
<span class="sd">    and returns a timeout in absolute deadline format.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">timeout</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),)</span></div>


<div class="viewcode-block" id="GetDeadline">
<a class="viewcode-back" href="../../user/cothread.html#cothread.GetDeadline">[docs]</a>
<span class="k">def</span> <span class="nf">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Returns the deadline associated with the given timeout, or None if there</span>
<span class="sd">    is no deadline.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">timeout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">timeout</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span></div>


<div class="viewcode-block" id="Deadline">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Deadline">[docs]</a>
<span class="k">def</span> <span class="nf">Deadline</span><span class="p">(</span><span class="n">deadline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Converts a deadline into a timeout.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">deadline</span><span class="p">,)</span></div>



<span class="k">class</span> <span class="nc">EventBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;The base class for implementing events and signals.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__wait_queue&#39;</span><span class="p">,</span>     <span class="c1"># Queue of cothreads waiting to be woken</span>
        <span class="s1">&#39;__wait_abort&#39;</span><span class="p">,</span>     <span class="c1"># Count of abortable waits.</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># List of tasks currently waiting to be woken up.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span> <span class="o">=</span> <span class="n">_WakeupQueue</span><span class="p">()</span>
        <span class="c1"># Number of aborted waits that need to be emulated.  This is</span>
        <span class="c1"># incremented by subclasses for each _Wakeup that needs to be</span>
        <span class="c1"># simulated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_WaitUntil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Suspends the calling task until _Wakeup() is called.  Raises an</span>
<span class="sd">        exception if a timeout occurs first.&#39;&#39;&#39;</span>
        <span class="c1"># If the event object is not ready we always yield control to ensure</span>
        <span class="c1"># that other ready cothreads get the opportunity to run.</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_scheduler</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Timedout</span><span class="p">(</span><span class="s1">&#39;Timed out waiting for event&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wake_all</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Wakes one or all waiting tasks.  Returns False if an aborted wait</span>
<span class="sd">        needs to be emulated.&#39;&#39;&#39;</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wake_all</span><span class="p">:</span>
            <span class="c1"># This is a special case: an aborted wait needs to be completed.</span>
            <span class="c1"># This occurs when waiting needs to be simulated, in which case</span>
            <span class="c1"># any resources consumed by the reader need to be consumed by the</span>
            <span class="c1"># waker instead!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wait_queue</span><span class="o">.</span><span class="n">wake</span><span class="p">(</span><span class="n">wake_all</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wait_abort</span> <span class="o">+=</span> <span class="mi">1</span>


<div class="viewcode-block" id="Spawn">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Spawn">[docs]</a>
<span class="k">class</span> <span class="nc">Spawn</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;This class is used to wrap cooperative threads: every task (except</span>
<span class="sd">    for main) managed by the scheduler should be an instance of this class.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__function&#39;</span><span class="p">,</span>       <span class="c1"># Function implementing cothread action</span>
        <span class="s1">&#39;__args&#39;</span><span class="p">,</span>           <span class="c1"># Positional arguments for action</span>
        <span class="s1">&#39;__kargs&#39;</span><span class="p">,</span>          <span class="c1"># Keyword arguments for action</span>
        <span class="s1">&#39;__result&#39;</span><span class="p">,</span>         <span class="c1"># Result when action has completed</span>
        <span class="s1">&#39;__raise_on_wait&#39;</span><span class="p">,</span>  <span class="c1"># Action to take on exception</span>
    <span class="p">]</span>

    <span class="c1"># Set of all active processes for debugging</span>
    <span class="n">Cothreads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The given function and arguments will be called as a new task.</span>
<span class="sd">        All of the arguments will be be passed through to function, except for</span>
<span class="sd">        the special keyword raise_on_wait which defaults to False.</span>
<span class="sd">            If raise_on_wait is set then any exception raised during the</span>
<span class="sd">        execution of this task will be postponed until Wait() is called.  This</span>
<span class="sd">        allows such exceptions to be caught without disturbing the normal</span>
<span class="sd">        operation of the system.  Otherwise any exception is reported.&#39;&#39;&#39;</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__kargs</span> <span class="o">=</span> <span class="n">kargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__raise_on_wait</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;raise_on_wait&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Hand control over to the run method in the scheduler.</span>
        <span class="n">_validate_thread</span><span class="p">()</span>
        <span class="n">_scheduler</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__run</span><span class="p">,</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stack_size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Cothreads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try for normal successful result.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__kargs</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Oops: the task terminated with an exception.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__raise_on_wait</span><span class="p">:</span>
                <span class="c1"># The creator of the task is willing to catch this exception,</span>
                <span class="c1"># so hang onto it now until Wait() is called.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No good.  We can&#39;t allow this exception to propagate, as</span>
                <span class="c1"># doing so will kill the scheduler.  Instead report the</span>
                <span class="c1"># traceback right here.</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Spawned task&#39;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__function</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;(unknown)&#39;</span><span class="p">),</span>
                    <span class="s1">&#39;raised uncaught exception&#39;</span><span class="p">,</span> <span class="n">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__result</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Aborted wakeup: consume the result now, will cause a subsequent</span>
            <span class="c1"># Wait() to fail, which it should.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Cothreads</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># See wait_until() for an explanation of this return value.</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Tests whether the event is signalled.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">)</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

<div class="viewcode-block" id="Spawn.Wait">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Spawn.Wait">[docs]</a>
    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Waits until the task has completed.  May raise an exception if the</span>
<span class="sd">        task terminated with an exception and raise_on_wait was selected.</span>
<span class="sd">        Can only be called once, as the result is deleted after call.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Re-raise the exception that actually killed the task here</span>
                <span class="c1"># where it can be received by whoever waits on the task.</span>
                <span class="n">py23</span><span class="o">.</span><span class="n">raise_with_traceback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># In this case result and self.__result contain a traceback.  To</span>
                <span class="c1"># avoid circular references which will delay garbage collection,</span>
                <span class="c1"># ensure these variables are deleted before the exception is</span>
                <span class="c1"># caught.</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
                <span class="k">del</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span><span class="p">:</span>
            <span class="c1"># Result has already arrived.  Consume it silently now.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Still need to wait: need to abort the next wakeup.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span></div>



<div class="viewcode-block" id="Event">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Event">[docs]</a>
<span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Any number of tasks can wait for an event to occur.  A single value</span>
<span class="sd">    can also be associated with the event.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__value&#39;</span><span class="p">,</span>          <span class="c1"># Value on this event</span>
        <span class="s1">&#39;__auto_reset&#39;</span><span class="p">,</span>     <span class="c1"># Whether value is consumed when taken</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto_reset</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;An event object is either signalled or reset.  Any task can wait</span>
<span class="sd">        for the object to become signalled, and it will be suspended until</span>
<span class="sd">        this occurs.</span>

<span class="sd">        The intial value can be specified, as can the behaviour on succesfully</span>
<span class="sd">        signalling a process: if auto_reset=True is specified then only one</span>
<span class="sd">        task at a time sees any individual signal on this object.&#39;&#39;&#39;</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span> <span class="o">=</span> <span class="n">auto_reset</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Tests whether the event is signalled.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

<div class="viewcode-block" id="Event.Wait">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Event.Wait">[docs]</a>
    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The caller will block until the event becomes true, or until the</span>
<span class="sd">        timeout occurs if a timeout is specified.  A Timeout exception is</span>
<span class="sd">        raised if a timeout occurs.&#39;&#39;&#39;</span>
        <span class="c1"># If one task resets the event while another is waiting the wait may</span>
        <span class="c1"># fail, so we have to loop here.</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span>

        <span class="n">ok</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">:</span>
            <span class="c1"># If this is an auto reset event then we reset it on exit;</span>
            <span class="c1"># this means that we&#39;re the only thread that sees it being</span>
            <span class="c1"># signalled.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Finally return the result as a value or raise an exception.</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="c1"># If this isn&#39;t an auto_reset event then our aborted wait makes no</span>
        <span class="c1"># difference.  Otherwise we either consume the value now or on the</span>
        <span class="c1"># next wakeup.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span>

<div class="viewcode-block" id="Event.Signal">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Event.Signal">[docs]</a>
    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Signals the event.  Any waiting tasks are scheduled to be woken.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span></div>


<div class="viewcode-block" id="Event.SignalException">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Event.SignalException">[docs]</a>
    <span class="k">def</span> <span class="nf">SignalException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Signals the event with an exception: the next call to wait will</span>
<span class="sd">        receive an exception instead of a normal return value.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__auto_reset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Reset</span><span class="p">()</span></div>


<div class="viewcode-block" id="Event.Reset">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Event.Reset">[docs]</a>
    <span class="k">def</span> <span class="nf">Reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Resets the event (and erases the value).&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="p">()</span></div>
</div>



<div class="viewcode-block" id="Pulse">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Pulse">[docs]</a>
<span class="k">class</span> <span class="nc">Pulse</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Somewhat equivalent to pthread condition variable: any number of waiters</span>
<span class="sd">    will be woken by calling the Signal() method, but there is no state and</span>
<span class="sd">    nothing is returned from Wait().&#39;&#39;&#39;</span>

<div class="viewcode-block" id="Pulse.Wait">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Pulse.Wait">[docs]</a>
    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pulse.Signal">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Pulse.Signal">[docs]</a>
    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wake_all</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="n">wake_all</span><span class="p">)</span></div>


    <span class="n">AbortWait</span> <span class="o">=</span> <span class="n">EventBase</span><span class="o">.</span><span class="n">_AbortWait</span></div>



<div class="viewcode-block" id="EventQueue">
<a class="viewcode-back" href="../../user/cothread.html#cothread.EventQueue">[docs]</a>
<span class="k">class</span> <span class="nc">EventQueue</span><span class="p">(</span><span class="n">EventBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A queue of objects.  A queue can also be treated as an iterator.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__queue&#39;</span><span class="p">,</span>          <span class="c1"># Queue of values</span>
        <span class="s1">&#39;__closed&#39;</span><span class="p">,</span>         <span class="c1"># Used to halt iteration over this queue</span>
        <span class="s1">&#39;__max_length&#39;</span><span class="p">,</span>     <span class="c1"># Maximum length of queue</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">EventBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__max_length</span> <span class="o">=</span> <span class="n">max_length</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the number of objects waiting on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">)</span>

<div class="viewcode-block" id="EventQueue.Wait">
<a class="viewcode-back" href="../../user/cothread.html#cothread.EventQueue.Wait">[docs]</a>
    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the next object from the queue, or raises a Timeout</span>
<span class="sd">        exception if the timeout expires first.&#39;&#39;&#39;</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WaitUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span></div>


    <span class="k">def</span> <span class="nf">AbortWait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Called instead of performing a proper wait to release any resources</span>
<span class="sd">        that might be consumed until the wait occurs.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AbortWait</span><span class="p">()</span>

<div class="viewcode-block" id="EventQueue.Signal">
<a class="viewcode-back" href="../../user/cothread.html#cothread.EventQueue.Signal">[docs]</a>
    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Adds the given value to the tail of the queue.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">,</span> <span class="s1">&#39;Can</span><span class="se">\&#39;</span><span class="s1">t write to a closed queue&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_length</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="EventQueue.Reset">
<a class="viewcode-back" href="../../user/cothread.html#cothread.EventQueue.Reset">[docs]</a>
    <span class="k">def</span> <span class="nf">Reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Discards all values in queue.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__queue</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="EventQueue.close">
<a class="viewcode-back" href="../../user/cothread.html#cothread.EventQueue.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;An event queue can be closed.  This will cause waiting to raise</span>
<span class="sd">        the StopIteration exception (once existing entries have been read),</span>
<span class="sd">        and will prevent any further signals to the queue.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Wakeup</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;An event queue can itself be treated as an iterator: this allows</span>
<span class="sd">        event dispatching using a for loop, and provides some support for</span>
<span class="sd">        combining queues.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="fm">__next__</span> <span class="o">=</span> <span class="nb">next</span></div>



<div class="viewcode-block" id="ThreadedEventQueue">
<a class="viewcode-back" href="../../user/cothread.html#cothread.ThreadedEventQueue">[docs]</a>
<span class="k">class</span> <span class="nc">ThreadedEventQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;An event queue designed to work with threads.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__values&#39;</span><span class="p">,</span>         <span class="c1"># List of queued values</span>
        <span class="s1">&#39;__signal&#39;</span><span class="p">,</span>         <span class="c1"># File handle used to notify new value</span>
        <span class="s1">&#39;wait_descriptor&#39;</span><span class="p">,</span>  <span class="c1"># File handle waited on for new values</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># According to the documentation this is thread safe, so we don&#39;t</span>
        <span class="c1"># need to take any particular precautions when using this!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the number of objects waiting on the queue.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Waits for a value to be written to the queue.  This can safely be</span>
<span class="sd">        called from either a cothread or another thread: the appropriate form</span>
<span class="sd">        of cooperative or normal blocking will be selected automatically.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span> <span class="o">==</span> <span class="n">scheduler_thread_id</span><span class="p">:</span>
            <span class="c1"># Normal cothread case, use cooperative wait</span>
            <span class="n">poll</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Another thread, so block caller until ready</span>
            <span class="n">poll</span> <span class="o">=</span> <span class="n">coselect</span><span class="o">.</span><span class="n">poll_block</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">poll</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="n">coselect</span><span class="o">.</span><span class="n">POLLIN</span><span class="p">)],</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Timedout</span><span class="p">(</span><span class="s1">&#39;Timed out waiting for signal&#39;</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_descriptor</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Posts a value to the event queue.  This can safely be called from</span>
<span class="sd">        a thread or a cothread.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;-&#39;</span><span class="p">)</span></div>




<span class="c1"># Implements asynchronous (and &quot;lock free&quot;) synchronisation from any Python</span>
<span class="c1"># thread to the main cothread thread.  Technically the Python Global Interpreter</span>
<span class="c1"># Lock (GIL) plays an essential role in this code by serialising all the actions</span>
<span class="c1"># here and ensuring that collections.deque actions are atomic (which follows</span>
<span class="c1"># from its implementation as a C extension).</span>
<span class="c1">#</span>
<span class="c1"># Note that the signalling from Callback() to the callback_events() loop is</span>
<span class="c1"># rather delicate.  Care is taken here to reduce the number of os.read/write</span>
<span class="c1"># actions as these involve costly system calls, but without the hazard of losing</span>
<span class="c1"># events which would result in deadlock.</span>
<span class="k">class</span> <span class="nc">_Callback</span><span class="p">:</span>
    <span class="n">COTHREAD_CALLBACK_STACK</span> <span class="o">=</span> \
        <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;COTHREAD_CALLBACK_STACK&#39;</span><span class="p">,</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pipe</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">Spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_events</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COTHREAD_CALLBACK_STACK</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">callback_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">coselect</span><span class="o">.</span><span class="n">poll_list</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">coselect</span><span class="o">.</span><span class="n">POLLIN</span><span class="p">)])</span>
                <span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>    <span class="c1"># Consume all pending wakeups</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">action</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">action</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Asynchronous callback raised uncaught exception&#39;</span><span class="p">,</span>
                        <span class="n">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">args</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This can be called from within any Python thread to arrange for</span>
<span class="sd">        action(*args) to be called in the context of the cothread thread.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">action</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="CallbackResult">
<a class="viewcode-back" href="../../user/cothread.html#cothread.CallbackResult">[docs]</a>
<span class="k">def</span> <span class="nf">CallbackResult</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Perform action in the main cothread and return a result.&#39;&#39;&#39;</span>
    <span class="n">callback</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;callback_queue&#39;</span><span class="p">,</span> <span class="n">Callback</span><span class="p">)</span>
    <span class="n">timeout</span>  <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;callback_timeout&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">spawn</span>    <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;callback_spawn&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scheduler_thread_id</span> <span class="o">==</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">action</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">action_result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">do_action</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">action_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">action_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">action_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">action_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="c1"># Hand the action over to the cothread carrying thread for action and</span>
        <span class="c1"># wait for the result.</span>
        <span class="k">if</span> <span class="n">spawn</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">Spawn</span><span class="p">,</span> <span class="n">do_action</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">do_action</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Timedout</span><span class="p">(</span><span class="s1">&#39;Timed out waiting for callback result&#39;</span><span class="p">)</span>

        <span class="c1"># Return result or raise caught exception as appropriate.</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">action_result</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">py23</span><span class="o">.</span><span class="n">raise_with_traceback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


        <span class="c1"># Note: raising entire stack backtrace context might be dangerous, need</span>
        <span class="c1"># to think about this carefully, particularly if the corresponding stack</span>
        <span class="c1"># has been swapped out...</span>


<div class="viewcode-block" id="Timer">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Timer">[docs]</a>
<span class="k">class</span> <span class="nc">Timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A cancellable one-shot or auto-retriggering timer.&#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__timeout&#39;</span><span class="p">,</span>        <span class="c1"># Time to wait until triggering timer</span>
        <span class="s1">&#39;__callback&#39;</span><span class="p">,</span>       <span class="c1"># Function to call when timer fires</span>
        <span class="s1">&#39;__retrigger&#39;</span><span class="p">,</span>      <span class="c1"># Enables retriggering timers</span>
        <span class="s1">&#39;__reuse&#39;</span><span class="p">,</span>          <span class="c1"># Set if timer can be reused</span>
        <span class="s1">&#39;__control&#39;</span><span class="p">,</span>        <span class="c1"># Event object for controlling timer</span>
        <span class="s1">&#39;__fire&#39;</span><span class="p">,</span>           <span class="c1"># Controls action when event timeout occurs</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">retrigger</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reuse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The callback will be called (with no arguments) after the specified</span>
<span class="sd">        timeout.  If retrigger is set then the timer will automatically</span>
<span class="sd">        retrigger until it is cancelled.  Unless reuse or retrigger is set the</span>
<span class="sd">        timer will be cancelled once it fires and cannot be reused.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span> <span class="s1">&#39;Ensure the callback is callable&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span> <span class="o">=</span> <span class="n">retrigger</span>        <span class="c1"># Auto retrigger on each timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span> <span class="o">=</span> <span class="n">reuse</span> <span class="ow">or</span> <span class="n">retrigger</span>   <span class="c1"># Keep timer alive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>            <span class="c1"># Used to control main loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="kc">True</span>                  <span class="c1"># False if control event pending</span>
        <span class="n">Spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timer</span><span class="p">,</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="n">stack_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__timer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Timedout</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span><span class="p">:</span>
                        <span class="c1"># Unless we&#39;re automatically retriggering, any new</span>
                        <span class="c1"># timeout has to be specified anew.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="kc">True</span>      <span class="c1"># We&#39;ve seen the control event</span>

            <span class="n">running</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__callback</span>     <span class="c1"># Try to avoid reference loops</span>

<div class="viewcode-block" id="Timer.cancel">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Timer.cancel">[docs]</a>
    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Cancels the timer: the timer is guaranteed not to fire once this</span>
<span class="sd">        call has been made.  A cancelled timer cannot be reset.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span></div>


<div class="viewcode-block" id="Timer.reset">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Timer.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">retrigger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Resets the timer.  The timeout is reset to the given timeout and the</span>
<span class="sd">        timer is restarted.  A timeout of None can be used to temporarily</span>
<span class="sd">        suspend a timer.&#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__reuse</span><span class="p">,</span> <span class="s1">&#39;Cannot reuse this timer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="k">if</span> <span class="n">retrigger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__retrigger</span> <span class="o">=</span> <span class="n">retrigger</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__fire</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__control</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="WaitForAll">
<a class="viewcode-back" href="../../user/cothread.html#cothread.WaitForAll">[docs]</a>
<span class="k">def</span> <span class="nf">WaitForAll</span><span class="p">(</span><span class="n">event_list</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Waits for all events in the event list to become ready or for the</span>
<span class="sd">    timeout to expire.&#39;&#39;&#39;</span>
    <span class="c1"># Make sure that the timeout is actually a deadline, then it&#39;s easy to do</span>
    <span class="c1"># all the waits in sequence.</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="n">AbsTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
    <span class="c1"># Unfortunately our waiting can be interrupted by an exception.  To avoid</span>
    <span class="c1"># leaking memory in this case we perform simulated waits on any remaining</span>
    <span class="c1"># events.  This is a good deal more complicated than</span>
    <span class="c1">#       return [event.Wait(timeout) for event in event_list]</span>
    <span class="c1"># which is what it ought to be!</span>
    <span class="n">event_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">event_list</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>      <span class="c1"># In case event_list is empty!</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event_list</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">Wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">event_list</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">AbortWait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span></div>




<span class="c1"># Other possibly desirable entites:</span>
<span class="c1">#</span>
<span class="c1">#   The ability to wait for an event to occur on one of a set of objects.</span>
<span class="c1">#       This would probably require quite deep hooking into the queueing</span>
<span class="c1">#       mechanism, and seems of limited value (the natural alternative is to</span>
<span class="c1">#       create a task per event).</span>
<span class="c1">#</span>
<span class="c1">#   The ability to kill a task</span>
<span class="c1">#       This is probably doable with something equivalent to the .throw greenlet</span>
<span class="c1">#       method (or even with a special wakeup value), but may require some care.</span>


<span class="n">_QuitEvent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">auto_reset</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="Quit">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Quit">[docs]</a>
<span class="k">def</span> <span class="nf">Quit</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Signals the quit event.  Once signalled it stays signalled.&#39;&#39;&#39;</span>
    <span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span></div>


<div class="viewcode-block" id="WaitForQuit">
<a class="viewcode-back" href="../../user/cothread.html#cothread.WaitForQuit">[docs]</a>
<span class="k">def</span> <span class="nf">WaitForQuit</span><span class="p">(</span><span class="n">catch_interrupt</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Waits for the quit event to be signalled.  If catch_interrupt is True</span>
<span class="sd">    then control-C will only signal the quit event and will not generate an</span>
<span class="sd">    exception; this does mean that the only way to interrupt a misbehaving loop</span>
<span class="sd">    is to use another signal such as SIGQUIT (C-\\)&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">catch_interrupt</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">signal</span>
        <span class="k">def</span> <span class="nf">quit</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
            <span class="n">Callback</span><span class="p">(</span><span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Signal</span><span class="p">)</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">quit</span><span class="p">)</span>

    <span class="n">_QuitEvent</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span></div>



<span class="c1"># There is only the one scheduler, which we create right away.  A dedicated</span>
<span class="c1"># scheduler task is created: this allows the main task to suspend, but does</span>
<span class="c1"># mean that the scheduler is not the parent of all the tasks it&#39;s managing.</span>
<span class="n">_scheduler</span> <span class="o">=</span> <span class="n">_Scheduler</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="c1"># We hang onto the thread ID for the cothread thread (at present there can</span>
<span class="c1"># only be one) so that we can recognise when we&#39;re in another thread.</span>
<span class="n">scheduler_thread_id</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>


<span class="c1"># Thread validation: ensure cothreads aren&#39;t used across threads!</span>
<span class="k">def</span> <span class="nf">_validate_thread</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">scheduler_thread_id</span> <span class="o">==</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span><span class="p">(),</span> \
        <span class="s1">&#39;Cannot call into cothread from another thread.  Consider using &#39;</span> \
        <span class="s1">&#39;Callback or CallbackResult.&#39;</span>

<span class="c1"># This is the asynchronous callback method.</span>
<span class="n">Callback</span> <span class="o">=</span> <span class="n">_Callback</span><span class="p">()</span>


<div class="viewcode-block" id="SleepUntil">
<a class="viewcode-back" href="../../user/cothread.html#cothread.SleepUntil">[docs]</a>
<span class="k">def</span> <span class="nf">SleepUntil</span><span class="p">(</span><span class="n">deadline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Sleep until the specified deadline.  Control will always be yielded,</span>
<span class="sd">    even if the timeout has already passed.&#39;&#39;&#39;</span>
    <span class="n">_validate_thread</span><span class="p">()</span>
    <span class="n">_scheduler</span><span class="o">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sleep">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Sleep">[docs]</a>
<span class="k">def</span> <span class="nf">Sleep</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Sleep until the specified timeout has expired.&#39;&#39;&#39;</span>
    <span class="n">SleepUntil</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span></div>


<div class="viewcode-block" id="Yield">
<a class="viewcode-back" href="../../user/cothread.html#cothread.Yield">[docs]</a>
<span class="k">def</span> <span class="nf">Yield</span><span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Hands control back to the scheduler.  Control is returned either after</span>
<span class="sd">    the specified timeout has passed, or as soon as there are no active jobs</span>
<span class="sd">    waiting to be run.&#39;&#39;&#39;</span>
    <span class="n">_validate_thread</span><span class="p">()</span>
    <span class="n">_scheduler</span><span class="o">.</span><span class="n">do_yield</span><span class="p">(</span><span class="n">GetDeadline</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span></div>



<div class="viewcode-block" id="RLock">
<a class="viewcode-back" href="../../user/cothread.html#cothread.RLock">[docs]</a>
<span class="k">class</span> <span class="nc">RLock</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A reentrant lock.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;__event&#39;</span><span class="p">,</span>          <span class="c1"># Underlying event object</span>
        <span class="s1">&#39;__owner&#39;</span><span class="p">,</span>          <span class="c1"># The coroutine that has locked</span>
        <span class="s1">&#39;__count&#39;</span><span class="p">,</span>          <span class="c1"># The number of times the owner has locked</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="c1"># Start off with the event set so acquire will not block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="RLock.acquire">
<a class="viewcode-back" href="../../user/cothread.html#cothread.RLock.acquire">[docs]</a>
    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Acquire the lock if necessary and increment the recursion level.&quot;&quot;&quot;</span>
        <span class="c1"># Inspired by threading.RLock</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="ow">and</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__owner</span><span class="p">,</span> <span class="n">me</span><span class="p">):</span>
            <span class="c1"># if we are the owner then just increment the count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise wait until it is unlocked</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__event</span><span class="o">.</span><span class="n">Wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="n">me</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="RLock.release">
<a class="viewcode-back" href="../../user/cothread.html#cothread.RLock.release">[docs]</a>
    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Release a lock, decrementing the recursion level.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="ow">and</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span><span class="p">,</span> <span class="n">_coroutine</span><span class="o">.</span><span class="n">get_current</span><span class="p">()),</span> \
            <span class="s2">&quot;cannot release un-acquired lock&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Wakeup one cothread waiting on acquire()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__event</span><span class="o">.</span><span class="n">Signal</span><span class="p">()</span></div>


    <span class="c1"># Needed to make it a context manager</span>
    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>